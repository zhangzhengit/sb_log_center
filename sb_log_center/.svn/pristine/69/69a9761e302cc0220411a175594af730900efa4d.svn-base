package com.vo.api;


import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.LinkedBlockingQueue;

import javax.transaction.Transactional;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.google.common.collect.Lists;
import com.vo.entity.AddDTO;
import com.vo.entity.AddRequest;
import com.vo.entity.AppEntity;
import com.vo.entity.AppService;
import com.vo.entity.LogEntity;
import com.vo.entity.LogRepository;
import com.vo.entity.LogService;
import com.votool.common.CR;
import com.votool.common.ZPU;
import com.votool.ze.ZE;
import com.votool.ze.ZES;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.collection.ListUtil;
import cn.hutool.core.lang.UUID;

/**
 *
 *
 * @author zhangzhen
 * @date 2022年11月24日
 *
 */
@Controller
public class API implements InitializingBean {


	private final ZE ZE = ZES.newSingleZE();

//	@Autowired
//	private Conf conf;
	@Autowired
	private AppService appService;
	@Autowired
	private LogRepository logRepository;
	@Autowired
	private LogService logService;

	private final String addAsyncLOCK = new String(String.valueOf(UUID.randomUUID()));

	private final Queue<AddRequest> addQueue = new LinkedBlockingQueue<>();

	@GetMapping
	public String index(final Model model, @RequestParam(required = false) final String k,
			@RequestParam(required = false,defaultValue = "-1") final Integer app) {

		this.initAppList(model);

		final boolean done = LogService.indexDone.get();
		if (!done) {
			model.addAttribute("message", "提示：正在建立索引，请等待完成后重试【搜索】");
			model.addAttribute("list", Collections.emptyList());
			model.addAttribute("k", k);
			model.addAttribute("t", 1);
			return "index";
		}

		if (StringUtils.isEmpty(k)) {
			model.addAttribute("list", Collections.emptyList());
			model.addAttribute("t", 1);
			return "index";
		}

		// FIXME 2022年12月15日 下午10:27:57 zhanghen: 对命中k的关键字修改css
		final List<LogEntity> list = this.logService.search(k, app);

		model.addAttribute("list", list);
		model.addAttribute("k", k);
		model.addAttribute("t", 2);

		return "index";
	}



	private void initAppList(final Model model) {
		final List<AppEntity> appList = this.appService.findAll();
		model.addAttribute("appList", appList);
	}



	@PostMapping(value = "/add")
	@ResponseBody
	public CR add2(@RequestBody final LogEntity logEntity) {
//		synchronized (this.addAsyncLOCK) {
//			this.addQueue.add(addRequest);
//		}

		this.logRepository.save(logEntity);

		return CR.ok();
	}

	@PostMapping
	@ResponseBody
	public CR add(@RequestBody final AddRequest addRequest) {

		// 1
//		synchronized (this.addAsyncLOCK) {
//			this.addQueue.add(addRequest);
//		}

		// 2
		final List<byte[]> l = addRequest.getList();
		for (final byte[] bs : l) {
			final LogEntity one = one(bs);
			this.logRepository.save(one);
		}

		return CR.ok();
	}

	@Transactional(rollbackOn = Exception.class)
	public void save0() {
		System.out.println(
				java.time.LocalDateTime.now() + "\t" + Thread.currentThread().getName() + "\t" + "API.save0()");

		while (true) {

			if (CollUtil.isEmpty(this.addQueue)) {
				synchronized (this.addAsyncLOCK) {
					try {
						this.addAsyncLOCK.wait(1);
					} catch (final InterruptedException e) {
						e.printStackTrace();
					}
				}

			} else {

				if (CollUtil.isEmpty(this.addQueue)) {
					continue;
				}

				final List<AddRequest> addRequestList = Lists.newArrayListWithCapacity(this.addQueue.size());
				while (!this.addQueue.isEmpty()) {
					final AddRequest poll = this.addQueue.poll();
					if (Objects.isNull(poll)) {
						break;
					}
					addRequestList.add(poll);
				}

				final List<LogEntity> el = toLogEntityList(addRequestList);
				this.logRepository.saveAll(el);
				System.out.println("this.logRepository.saveAll(el);.size = " + el.size());

//				this.ZE.executeInQueue(() -> {
//					final List<LogEntity> logEntityList = API.toLogEntityList(addRequestList);

//					final int size = this.conf.getBatchSaveSize();
//					final List<List<LogEntity>> splitList = splitList(logEntityList, size);
//					splitList.stream().forEach(this.logService::saveAll_0);

//					logEntityList.stream().forEach(this.logService::saveAll_0);

//				});

			}
		}
	}

	private static <T> List<List<T>> splitList(final List<T> list, final int size) {
		if (CollUtil.isEmpty(list)) {
			return Collections.emptyList();
		}

		if (size <= 0 || list.size() <= size) {
			final ArrayList<List<T>> newArrayList = Lists.newArrayListWithCapacity(1);
			newArrayList.add(list);
			return newArrayList;
		}

		final ArrayList<List<T>> r = Lists.newArrayListWithCapacity(1);

		int fromIndex = 0;
		int toIndex = fromIndex + size;
		while (true) {
			final List<T> subList = ListUtil.sub(list, fromIndex, toIndex);

			r.add(subList);

			if (toIndex >= list.size()) {
				return r;
			}

			fromIndex = toIndex;
			toIndex = toIndex >= list.size() ? list.size() : fromIndex + size;
		}

	}

	private static List<LogEntity> toLogEntityList(final List<AddRequest> al) {

		if (CollUtil.isEmpty(al)) {
			return Collections.emptyList();
		}

		final ArrayList<LogEntity> el = Lists.newArrayList();
		for (final AddRequest addRequest : al) {

			final List<byte[]> bsList = addRequest.getList();
			for (final byte[] bs : bsList) {
				final LogEntity entity = one(bs);
				el.add(entity);
			}
		}

		return el;
	}



	private static LogEntity one(final byte[] bs) {
		final AddDTO addDTO = ZPU.deserialize(bs, AddDTO.class);
		final LogEntity entity = new LogEntity();
		entity.setCreateTime(new Date());
		entity.setContent(addDTO.getK());
		entity.setAppId(addDTO.getAppId());
		entity.setAppName(addDTO.getAppName());
		return entity;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		System.out.println(java.time.LocalDateTime.now() + "\t" + Thread.currentThread().getName() + "\t"
				+ "APimplements.afterPropertiesSet()");

		final Thread thread = new Thread(() -> API.this.save0());
		thread.setName("API-add-save0-Thread");
		thread.start();
	}

}
